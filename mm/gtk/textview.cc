// Generated by gmmproc 2.74.0 -- DO NOT MODIFY!


#include <mm/glib/mm-glib.h>

#include <mm/gtk/textview.h>
#include <mm/gtk/private/textview_p.h>

#include <gtk/gtk.h>

/* Copyright 2002 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <gtk/gtk.h>

namespace Gtk
{

TextView::TextView(const Glib::RefPtr<TextBuffer>& buffer)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::Widget(Glib::ConstructParams(textview_class_.init()))
{
  set_buffer(buffer);
}

auto TextView::scroll_to(TextBuffer::iterator& iter, double within_margin) -> bool
{
  //The last 2 arguments are ignored if use_align is FALSE.
  return gtk_text_view_scroll_to_iter(gobj(), (iter).gobj(), within_margin, FALSE, 0.0, 0.0);
}

auto TextView::scroll_to(TextBuffer::iterator& iter, double within_margin, double xalign, double yalign) -> bool
{
  return gtk_text_view_scroll_to_iter(gobj(), (iter).gobj(), within_margin, TRUE /* use_align */, xalign, yalign);
}

void TextView::scroll_to(const Glib::RefPtr<TextBuffer::Mark>& mark, double within_margin)
{
  //The last 2 arguments are ignored if use_align is FALSE.
  gtk_text_view_scroll_to_mark(gobj(), Glib::unwrap(mark), within_margin, FALSE, 0.0, 0.0);
}

void TextView::scroll_to(const Glib::RefPtr<TextBuffer::Mark>& mark, double within_margin, double xalign, double yalign)
{
  gtk_text_view_scroll_to_mark(gobj(), Glib::unwrap(mark), within_margin, TRUE /* use_align */, xalign, yalign);
}

void TextView::unset_gutter(TextWindowType win)
{
  gtk_text_view_set_gutter(gobj(), static_cast<GtkTextWindowType>(win), nullptr);
}

} // namespace Gtk

namespace
{


const Glib::SignalProxyInfo TextView_signal_set_anchor_info =
{
  "set_anchor",
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback,
  (GCallback) &Glib::SignalProxyNormal::slot0_void_callback
};


void TextView_signal_insert_at_cursor_callback(GtkTextView* self, const gchar* p0,void* data)
{
  using namespace Gtk;
  using SlotType = sigc::slot<void(const Glib::ustring&)>;

  auto obj = dynamic_cast<TextView*>(Glib::ObjectBase::_get_current_wrapper((GObject*) self));
  // Do not try to call a signal on a disassociated wrapper.
  if(obj)
  {
    try
    {
      if(const auto slot = Glib::SignalProxyNormal::data_to_slot(data))
        (*static_cast<SlotType*>(slot))(Glib::convert_const_gchar_ptr_to_ustring(p0)
);
    }
    catch(...)
    {
       Glib::exception_handlers_invoke();
    }
  }
}

const Glib::SignalProxyInfo TextView_signal_insert_at_cursor_info =
{
  "insert_at_cursor",
  (GCallback) &TextView_signal_insert_at_cursor_callback,
  (GCallback) &TextView_signal_insert_at_cursor_callback
};


} // anonymous namespace

// static
auto Glib::Value<Gtk::TextWindowType>::value_type() -> GType
{
  return gtk_text_window_type_get_type();
}


namespace Glib
{

auto wrap(GtkTextView* object, bool take_copy) -> Gtk::TextView*
{
  return dynamic_cast<Gtk::TextView *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gtk
{


/* The *_Class implementation: */

auto TextView_Class::init() -> const Glib::Class&
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &TextView_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gtk_text_view_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:
  Scrollable::add_interface(get_type());

  }

  return *this;
}


void TextView_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


  klass->set_anchor = &set_anchor_callback;
  klass->insert_at_cursor = &insert_at_cursor_callback;
}


void TextView_Class::set_anchor_callback(GtkTextView* self)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        obj->on_set_anchor();
        return;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  const auto base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

  // Call the original underlying C function:
  if(base && base->set_anchor)
    (*base->set_anchor)(self);
}
void TextView_Class::insert_at_cursor_callback(GtkTextView* self, const gchar* p0)
{
  const auto obj_base = static_cast<Glib::ObjectBase*>(
      Glib::ObjectBase::_get_current_wrapper((GObject*)self));

  // Non-gtkmmproc-generated custom classes implicitly call the default
  // Glib::ObjectBase constructor, which sets is_derived_. But gtkmmproc-
  // generated classes can use this optimisation, which avoids the unnecessary
  // parameter conversions if there is no possibility of the virtual function
  // being overridden:
  if(obj_base && obj_base->is_derived_())
  {
    const auto obj = dynamic_cast<CppObjectType* const>(obj_base);
    if(obj) // This can be NULL during destruction.
    {
      try // Trap C++ exceptions which would normally be lost because this is a C callback.
      {
        // Call the virtual member method, which derived classes might override.
        obj->on_insert_at_cursor(Glib::convert_const_gchar_ptr_to_ustring(p0)
);
        return;
      }
      catch(...)
      {
        Glib::exception_handlers_invoke();
      }
    }
  }

  const auto base = static_cast<BaseClassType*>(
        g_type_class_peek_parent(G_OBJECT_GET_CLASS(self)) // Get the parent class of the object class (The original underlying C class).
    );

  // Call the original underlying C function:
  if(base && base->insert_at_cursor)
    (*base->insert_at_cursor)(self, p0);
}


auto TextView_Class::wrap_new(GObject* o) -> Glib::ObjectBase*
{
  return manage(new TextView((GtkTextView*)(o)));

}


/* The implementation: */

TextView::TextView(const Glib::ConstructParams& construct_params)
:
  Gtk::Widget(construct_params)
{
  }

TextView::TextView(GtkTextView* castitem)
:
  Gtk::Widget((GtkWidget*)(castitem))
{
  }


TextView::TextView(TextView&& src) noexcept
: Gtk::Widget(std::move(src))
  , Scrollable(std::move(src))
{}

auto TextView::operator=(TextView&& src) noexcept -> TextView&
{
  Gtk::Widget::operator=(std::move(src));
  Scrollable::operator=(std::move(src));
  return *this;
}

TextView::~TextView() noexcept
{
  destroy_();
}

TextView::CppClassType TextView::textview_class_; // initialize static member

auto TextView::get_type() -> GType
{
  return textview_class_.init().get_type();
}


auto TextView::get_base_type() -> GType
{
  return gtk_text_view_get_type();
}


TextView::TextView()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::Widget(Glib::ConstructParams(textview_class_.init()))
{


}

void TextView::set_buffer(const Glib::RefPtr<TextBuffer>& buffer)
{
  gtk_text_view_set_buffer(gobj(), Glib::unwrap(buffer));
}

auto TextView::get_buffer() -> Glib::RefPtr<TextBuffer>
{
  auto retvalue = Glib::wrap(gtk_text_view_get_buffer(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

auto TextView::get_buffer() const -> Glib::RefPtr<const TextBuffer>
{
  return const_cast<TextView*>(this)->get_buffer();
}

auto TextView::move_mark_onscreen(const Glib::RefPtr<TextBuffer::Mark>& mark) -> bool
{
  return gtk_text_view_move_mark_onscreen(gobj(), Glib::unwrap(mark));
}

auto TextView::place_cursor_onscreen() -> bool
{
  return gtk_text_view_place_cursor_onscreen(gobj());
}

void TextView::get_visible_rect(Gdk::Rectangle& visible_rect) const
{
  gtk_text_view_get_visible_rect(const_cast<GtkTextView*>(gobj()), (visible_rect).gobj());
}

void TextView::set_cursor_visible(bool setting)
{
  gtk_text_view_set_cursor_visible(gobj(), static_cast<int>(setting));
}

auto TextView::get_cursor_visible() const -> bool
{
  return gtk_text_view_get_cursor_visible(const_cast<GtkTextView*>(gobj()));
}

void TextView::reset_cursor_blink()
{
  gtk_text_view_reset_cursor_blink(gobj());
}

void TextView::get_cursor_locations(const TextBuffer::const_iterator& iter, Gdk::Rectangle& strong, Gdk::Rectangle& weak) const
{
  gtk_text_view_get_cursor_locations(const_cast<GtkTextView*>(gobj()), (iter).gobj(), (strong).gobj(), (weak).gobj());
}

void TextView::get_cursor_locations(Gdk::Rectangle& strong, Gdk::Rectangle& weak) const
{
  gtk_text_view_get_cursor_locations(const_cast<GtkTextView*>(gobj()), nullptr, (strong).gobj(), (weak).gobj());
}

void TextView::get_iter_location(const TextBuffer::const_iterator& iter, Gdk::Rectangle& location) const
{
  gtk_text_view_get_iter_location(const_cast<GtkTextView*>(gobj()), (iter).gobj(), (location).gobj());
}

auto TextView::get_iter_at_location(TextBuffer::iterator& iter, int x, int y) -> bool
{
  return gtk_text_view_get_iter_at_location(gobj(), (iter).gobj(), x, y);
}

auto TextView::get_iter_at_location(TextBuffer::const_iterator& iter, int x, int y) const -> bool
{
  return gtk_text_view_get_iter_at_location(const_cast<GtkTextView*>(gobj()), (iter).gobj(), x, y);
}

auto TextView::get_iter_at_position(TextBuffer::iterator& iter, int& trailing, int x, int y) -> bool
{
  return gtk_text_view_get_iter_at_position(gobj(), (iter).gobj(), &(trailing), x, y);
}

auto TextView::get_iter_at_position(TextBuffer::const_iterator& iter, int& trailing, int x, int y) const -> bool
{
  return gtk_text_view_get_iter_at_position(const_cast<GtkTextView*>(gobj()), (iter).gobj(), &(trailing), x, y);
}

void TextView::get_line_yrange(const TextBuffer::const_iterator& iter, int& y, int& height) const
{
  gtk_text_view_get_line_yrange(const_cast<GtkTextView*>(gobj()), (iter).gobj(), &(y), &(height));
}

void TextView::get_line_at_y(TextBuffer::iterator& target_iter, int y, int& line_top)
{
  gtk_text_view_get_line_at_y(gobj(), (target_iter).gobj(), y, &(line_top));
}

void TextView::get_line_at_y(TextBuffer::const_iterator& target_iter, int y, int& line_top) const
{
  gtk_text_view_get_line_at_y(const_cast<GtkTextView*>(gobj()), (target_iter).gobj(), y, &(line_top));
}

void TextView::buffer_to_window_coords(TextWindowType win, int buffer_x, int buffer_y, int& window_x, int& window_y) const
{
  gtk_text_view_buffer_to_window_coords(const_cast<GtkTextView*>(gobj()), static_cast<GtkTextWindowType>(win), buffer_x, buffer_y, &(window_x), &(window_y));
}

void TextView::window_to_buffer_coords(TextWindowType win, int window_x, int window_y, int& buffer_x, int& buffer_y) const
{
  gtk_text_view_window_to_buffer_coords(const_cast<GtkTextView*>(gobj()), static_cast<GtkTextWindowType>(win), window_x, window_y, &(buffer_x), &(buffer_y));
}

auto TextView::forward_display_line(TextBuffer::iterator& iter) -> bool
{
  return gtk_text_view_forward_display_line(gobj(), (iter).gobj());
}

auto TextView::backward_display_line(TextBuffer::iterator& iter) -> bool
{
  return gtk_text_view_backward_display_line(gobj(), (iter).gobj());
}

auto TextView::forward_display_line_end(TextBuffer::iterator& iter) -> bool
{
  return gtk_text_view_forward_display_line_end(gobj(), (iter).gobj());
}

auto TextView::backward_display_line_start(TextBuffer::iterator& iter) -> bool
{
  return gtk_text_view_backward_display_line_start(gobj(), (iter).gobj());
}

auto TextView::starts_display_line(const TextBuffer::iterator& iter) -> bool
{
  return gtk_text_view_starts_display_line(gobj(), (iter).gobj());
}

auto TextView::move_visually(TextBuffer::iterator& iter, int count) -> bool
{
  return gtk_text_view_move_visually(gobj(), (iter).gobj(), count);
}

auto TextView::im_context_filter_keypress(const Glib::RefPtr<Gdk::Event>& event) -> bool
{
  return gtk_text_view_im_context_filter_keypress(gobj(), Glib::unwrap(event));
}

void TextView::reset_im_context()
{
  gtk_text_view_reset_im_context(gobj());
}

auto TextView::get_gutter(TextWindowType win) -> Widget*
{
  return Glib::wrap(gtk_text_view_get_gutter(gobj(), static_cast<GtkTextWindowType>(win)));
}

auto TextView::get_gutter(TextWindowType win) const -> const Widget*
{
  return const_cast<TextView*>(this)->get_gutter(win);
}

void TextView::set_gutter(TextWindowType win, Widget& widget)
{
  gtk_text_view_set_gutter(gobj(), static_cast<GtkTextWindowType>(win), (widget).gobj());
}

void TextView::add_child_at_anchor(Widget& child, const Glib::RefPtr<TextBuffer::ChildAnchor>& anchor)
{
  gtk_text_view_add_child_at_anchor(gobj(), (child).gobj(), Glib::unwrap(anchor));
}

void TextView::add_overlay(Widget& child, int xpos, int ypos)
{
  gtk_text_view_add_overlay(gobj(), (child).gobj(), xpos, ypos);
}

void TextView::move_overlay(Widget& child, int xpos, int ypos)
{
  gtk_text_view_move_overlay(gobj(), (child).gobj(), xpos, ypos);
}

void TextView::remove(Widget& child)
{
  gtk_text_view_remove(gobj(), (child).gobj());
}

void TextView::set_wrap_mode(WrapMode wrap_mode)
{
  gtk_text_view_set_wrap_mode(gobj(), static_cast<GtkWrapMode>(wrap_mode));
}

auto TextView::get_wrap_mode() const -> WrapMode
{
  return static_cast<WrapMode>(gtk_text_view_get_wrap_mode(const_cast<GtkTextView*>(gobj())));
}

void TextView::set_editable(bool setting)
{
  gtk_text_view_set_editable(gobj(), static_cast<int>(setting));
}

auto TextView::get_editable() const -> bool
{
  return gtk_text_view_get_editable(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_pixels_above_lines(int pixels_above_lines)
{
  gtk_text_view_set_pixels_above_lines(gobj(), pixels_above_lines);
}

auto TextView::get_pixels_above_lines() const -> int
{
  return gtk_text_view_get_pixels_above_lines(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_pixels_below_lines(int pixels_below_lines)
{
  gtk_text_view_set_pixels_below_lines(gobj(), pixels_below_lines);
}

auto TextView::get_pixels_below_lines() const -> int
{
  return gtk_text_view_get_pixels_below_lines(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_pixels_inside_wrap(int pixels_inside_wrap)
{
  gtk_text_view_set_pixels_inside_wrap(gobj(), pixels_inside_wrap);
}

auto TextView::get_pixels_inside_wrap() const -> int
{
  return gtk_text_view_get_pixels_inside_wrap(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_justification(Justification justification)
{
  gtk_text_view_set_justification(gobj(), static_cast<GtkJustification>(justification));
}

auto TextView::get_justification() const -> Justification
{
  return static_cast<Justification>(gtk_text_view_get_justification(const_cast<GtkTextView*>(gobj())));
}

void TextView::set_left_margin(int left_margin)
{
  gtk_text_view_set_left_margin(gobj(), left_margin);
}

auto TextView::get_left_margin() const -> int
{
  return gtk_text_view_get_left_margin(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_right_margin(int right_margin)
{
  gtk_text_view_set_right_margin(gobj(), right_margin);
}

auto TextView::get_right_margin() const -> int
{
  return gtk_text_view_get_right_margin(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_top_margin(int top_margin)
{
  gtk_text_view_set_top_margin(gobj(), top_margin);
}

auto TextView::get_top_margin() const -> int
{
  return gtk_text_view_get_top_margin(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_bottom_margin(int bottom_margin)
{
  gtk_text_view_set_bottom_margin(gobj(), bottom_margin);
}

auto TextView::get_bottom_margin() const -> int
{
  return gtk_text_view_get_bottom_margin(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_indent(int indent)
{
  gtk_text_view_set_indent(gobj(), indent);
}

auto TextView::get_indent() const -> int
{
  return gtk_text_view_get_indent(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_tabs(Pango::TabArray& tabs)
{
  gtk_text_view_set_tabs(gobj(), (tabs).gobj());
}

auto TextView::get_tabs() const -> Pango::TabArray
{
  return Pango::TabArray((gtk_text_view_get_tabs(const_cast<GtkTextView*>(gobj()))), false);
}

void TextView::set_overwrite(bool overwrite)
{
  gtk_text_view_set_overwrite(gobj(), static_cast<int>(overwrite));
}

auto TextView::get_overwrite() const -> bool
{
  return gtk_text_view_get_overwrite(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_accepts_tab(bool accepts_tab)
{
  gtk_text_view_set_accepts_tab(gobj(), static_cast<int>(accepts_tab));
}

auto TextView::get_accepts_tab() const -> bool
{
  return gtk_text_view_get_accepts_tab(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_input_purpose(InputPurpose purpose)
{
  gtk_text_view_set_input_purpose(gobj(), static_cast<GtkInputPurpose>(purpose));
}

auto TextView::get_input_purpose() const -> InputPurpose
{
  return static_cast<InputPurpose>(gtk_text_view_get_input_purpose(const_cast<GtkTextView*>(gobj())));
}

void TextView::set_input_hints(InputHints hints)
{
  gtk_text_view_set_input_hints(gobj(), static_cast<GtkInputHints>(hints));
}

auto TextView::get_input_hints() const -> InputHints
{
  return static_cast<InputHints>(gtk_text_view_get_input_hints(const_cast<GtkTextView*>(gobj())));
}

void TextView::set_monospace(bool monospace)
{
  gtk_text_view_set_monospace(gobj(), static_cast<int>(monospace));
}

auto TextView::get_monospace() const -> bool
{
  return gtk_text_view_get_monospace(const_cast<GtkTextView*>(gobj()));
}

void TextView::set_extra_menu(const Glib::RefPtr<Gio::MenuModel>& model)
{
  gtk_text_view_set_extra_menu(gobj(), Glib::unwrap(model));
}

auto TextView::get_extra_menu() -> Glib::RefPtr<Gio::MenuModel>
{
  auto retvalue = Glib::wrap(gtk_text_view_get_extra_menu(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

auto TextView::get_extra_menu() const -> Glib::RefPtr<const Gio::MenuModel>
{
  return const_cast<TextView*>(this)->get_extra_menu();
}

auto TextView::get_rtl_context() -> Glib::RefPtr<Pango::Context>
{
  auto retvalue = Glib::wrap(gtk_text_view_get_rtl_context(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

auto TextView::get_rtl_context() const -> Glib::RefPtr<const Pango::Context>
{
  return const_cast<TextView*>(this)->get_rtl_context();
}

auto TextView::get_ltr_context() -> Glib::RefPtr<Pango::Context>
{
  auto retvalue = Glib::wrap(gtk_text_view_get_ltr_context(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

auto TextView::get_ltr_context() const -> Glib::RefPtr<const Pango::Context>
{
  return const_cast<TextView*>(this)->get_ltr_context();
}


auto TextView::signal_set_anchor() -> Glib::SignalProxy<void()>
{
  return Glib::SignalProxy<void() >(this, &TextView_signal_set_anchor_info);
}


auto TextView::signal_insert_at_cursor() -> Glib::SignalProxy<void(const Glib::ustring&)>
{
  return Glib::SignalProxy<void(const Glib::ustring&) >(this, &TextView_signal_insert_at_cursor_info);
}


auto TextView::property_pixels_above_lines() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "pixels-above-lines");
}

auto TextView::property_pixels_above_lines() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "pixels-above-lines");
}

auto TextView::property_pixels_below_lines() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "pixels-below-lines");
}

auto TextView::property_pixels_below_lines() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "pixels-below-lines");
}

auto TextView::property_pixels_inside_wrap() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "pixels-inside-wrap");
}

auto TextView::property_pixels_inside_wrap() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "pixels-inside-wrap");
}

auto TextView::property_editable() -> Glib::PropertyProxy< bool >
{
  return Glib::PropertyProxy< bool >(this, "editable");
}

auto TextView::property_editable() const -> Glib::PropertyProxy_ReadOnly< bool >
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "editable");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<WrapMode>::value,
  "Type WrapMode cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_wrap_mode() -> Glib::PropertyProxy< WrapMode >
{
  return Glib::PropertyProxy< WrapMode >(this, "wrap-mode");
}

auto TextView::property_wrap_mode() const -> Glib::PropertyProxy_ReadOnly< WrapMode >
{
  return Glib::PropertyProxy_ReadOnly< WrapMode >(this, "wrap-mode");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Justification>::value,
  "Type Justification cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_justification() -> Glib::PropertyProxy< Justification >
{
  return Glib::PropertyProxy< Justification >(this, "justification");
}

auto TextView::property_justification() const -> Glib::PropertyProxy_ReadOnly< Justification >
{
  return Glib::PropertyProxy_ReadOnly< Justification >(this, "justification");
}

auto TextView::property_left_margin() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "left-margin");
}

auto TextView::property_left_margin() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "left-margin");
}

auto TextView::property_right_margin() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "right-margin");
}

auto TextView::property_right_margin() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "right-margin");
}

auto TextView::property_top_margin() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "top-margin");
}

auto TextView::property_top_margin() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "top-margin");
}

auto TextView::property_bottom_margin() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "bottom-margin");
}

auto TextView::property_bottom_margin() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "bottom-margin");
}

auto TextView::property_indent() -> Glib::PropertyProxy< int >
{
  return Glib::PropertyProxy< int >(this, "indent");
}

auto TextView::property_indent() const -> Glib::PropertyProxy_ReadOnly< int >
{
  return Glib::PropertyProxy_ReadOnly< int >(this, "indent");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Pango::TabArray>::value,
  "Type Pango::TabArray cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_tabs() -> Glib::PropertyProxy< Pango::TabArray >
{
  return Glib::PropertyProxy< Pango::TabArray >(this, "tabs");
}

auto TextView::property_tabs() const -> Glib::PropertyProxy_ReadOnly< Pango::TabArray >
{
  return Glib::PropertyProxy_ReadOnly< Pango::TabArray >(this, "tabs");
}

auto TextView::property_cursor_visible() -> Glib::PropertyProxy< bool >
{
  return Glib::PropertyProxy< bool >(this, "cursor-visible");
}

auto TextView::property_cursor_visible() const -> Glib::PropertyProxy_ReadOnly< bool >
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "cursor-visible");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Glib::RefPtr<TextBuffer>>::value,
  "Type Glib::RefPtr<TextBuffer> cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_buffer() -> Glib::PropertyProxy< Glib::RefPtr<TextBuffer> >
{
  return Glib::PropertyProxy< Glib::RefPtr<TextBuffer> >(this, "buffer");
}

auto TextView::property_buffer() const -> Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TextBuffer> >
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<TextBuffer> >(this, "buffer");
}

auto TextView::property_overwrite() -> Glib::PropertyProxy< bool >
{
  return Glib::PropertyProxy< bool >(this, "overwrite");
}

auto TextView::property_overwrite() const -> Glib::PropertyProxy_ReadOnly< bool >
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "overwrite");
}

auto TextView::property_accepts_tab() -> Glib::PropertyProxy< bool >
{
  return Glib::PropertyProxy< bool >(this, "accepts-tab");
}

auto TextView::property_accepts_tab() const -> Glib::PropertyProxy_ReadOnly< bool >
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "accepts-tab");
}

auto TextView::property_im_module() -> Glib::PropertyProxy< Glib::ustring >
{
  return Glib::PropertyProxy< Glib::ustring >(this, "im-module");
}

auto TextView::property_im_module() const -> Glib::PropertyProxy_ReadOnly< Glib::ustring >
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "im-module");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<InputPurpose>::value,
  "Type InputPurpose cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_input_purpose() -> Glib::PropertyProxy< InputPurpose >
{
  return Glib::PropertyProxy< InputPurpose >(this, "input-purpose");
}

auto TextView::property_input_purpose() const -> Glib::PropertyProxy_ReadOnly< InputPurpose >
{
  return Glib::PropertyProxy_ReadOnly< InputPurpose >(this, "input-purpose");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<InputHints>::value,
  "Type InputHints cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_input_hints() -> Glib::PropertyProxy< InputHints >
{
  return Glib::PropertyProxy< InputHints >(this, "input-hints");
}

auto TextView::property_input_hints() const -> Glib::PropertyProxy_ReadOnly< InputHints >
{
  return Glib::PropertyProxy_ReadOnly< InputHints >(this, "input-hints");
}

auto TextView::property_monospace() -> Glib::PropertyProxy< bool >
{
  return Glib::PropertyProxy< bool >(this, "monospace");
}

auto TextView::property_monospace() const -> Glib::PropertyProxy_ReadOnly< bool >
{
  return Glib::PropertyProxy_ReadOnly< bool >(this, "monospace");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Glib::RefPtr<Gio::MenuModel>>::value,
  "Type Glib::RefPtr<Gio::MenuModel> cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

auto TextView::property_extra_menu() -> Glib::PropertyProxy< Glib::RefPtr<Gio::MenuModel> >
{
  return Glib::PropertyProxy< Glib::RefPtr<Gio::MenuModel> >(this, "extra-menu");
}

auto TextView::property_extra_menu() const -> Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gio::MenuModel> >
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<Gio::MenuModel> >(this, "extra-menu");
}


void Gtk::TextView::on_set_anchor()
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->set_anchor)
    (*base->set_anchor)(gobj());
}
void Gtk::TextView::on_insert_at_cursor(const Glib::ustring& str)
{
  const auto base = static_cast<BaseClassType*>(
      g_type_class_peek_parent(G_OBJECT_GET_CLASS(gobject_)) // Get the parent class of the object class (The original underlying C class).
  );

  if(base && base->insert_at_cursor)
    (*base->insert_at_cursor)(gobj(),str.c_str());
}


} // namespace Gtk


