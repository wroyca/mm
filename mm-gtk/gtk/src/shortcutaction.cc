// Generated by gmmproc 2.74.0 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gtkmm/shortcutaction.h>
#include <gtkmm/private/shortcutaction_p.h>


/* Copyright (C) 2020 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#include <gtk/gtk.h>
#include <gtkmm/widget.h>

namespace
{
gboolean SlotShortcut_callback(GtkWidget* widget, GVariant* args, gpointer user_data)
{
  auto the_slot = static_cast<Gtk::CallbackAction::SlotShortcut*>(user_data);

  try
  {
    return (*the_slot)(*Glib::wrap(widget, false), Glib::wrap(args, true));
  }
  catch (...)
  {
    Glib::exception_handlers_invoke();
  }
  return false;
}

} // anonymous namespace

namespace Gtk
{

CallbackAction::CallbackAction(const SlotShortcut& slot)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  // Create a copy of the slot object. A pointer to this will be passed
  // through the callback's user_data parameter. It will be deleted
  // when Glib::destroy_notify_delete<SlotShortcut>() is called.
  ShortcutAction(gtk_callback_action_new(&SlotShortcut_callback, new SlotShortcut(slot),
    &Glib::destroy_notify_delete<SlotShortcut>))
{
}

} // namespace Gtk

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gtk::ShortcutAction::Flags>::value_type()
{
  return gtk_shortcut_action_flags_get_type();
}


namespace Glib
{

Glib::RefPtr<Gtk::ShortcutAction> wrap(GtkShortcutAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::ShortcutAction>( dynamic_cast<Gtk::ShortcutAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& ShortcutAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &ShortcutAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_shortcut_action_get_type();

  }

  return *this;
}


void ShortcutAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* ShortcutAction_Class::wrap_new(GObject* object)
{
  return new ShortcutAction((GtkShortcutAction*)object);
}


/* The implementation: */

GtkShortcutAction* ShortcutAction::gobj_copy()
{
  reference();
  return gobj();
}

ShortcutAction::ShortcutAction(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

ShortcutAction::ShortcutAction(GtkShortcutAction* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


ShortcutAction::ShortcutAction(ShortcutAction&& src) noexcept
: Glib::Object(std::move(src))
{}

ShortcutAction& ShortcutAction::operator=(ShortcutAction&& src) noexcept
{
  Glib::Object::operator=(std::move(src));
  return *this;
}


ShortcutAction::~ShortcutAction() noexcept
{}


ShortcutAction::CppClassType ShortcutAction::shortcutaction_class_; // initialize static member

GType ShortcutAction::get_type()
{
  return shortcutaction_class_.init().get_type();
}


GType ShortcutAction::get_base_type()
{
  return gtk_shortcut_action_get_type();
}


ShortcutAction::ShortcutAction()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Glib::Object(Glib::ConstructParams(shortcutaction_class_.init()))
{
  

}

Glib::RefPtr<ShortcutAction> ShortcutAction::parse_string(const Glib::ustring& string)
{
  return Glib::wrap(gtk_shortcut_action_parse_string(string.c_str()));
}

Glib::ustring ShortcutAction::to_string() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_shortcut_action_to_string(const_cast<GtkShortcutAction*>(gobj())));
}

bool ShortcutAction::activate(Widget& widget, Flags flags, const Glib::VariantBase& args)
{
  return gtk_shortcut_action_activate(gobj(), static_cast<GtkShortcutActionFlags>(flags), (widget).gobj(), const_cast<GVariant*>((args).gobj()));
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::NothingAction> wrap(GtkNothingAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::NothingAction>( dynamic_cast<Gtk::NothingAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& NothingAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &NothingAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_nothing_action_get_type();

  }

  return *this;
}


void NothingAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* NothingAction_Class::wrap_new(GObject* object)
{
  return new NothingAction((GtkNothingAction*)object);
}


/* The implementation: */

GtkNothingAction* NothingAction::gobj_copy()
{
  reference();
  return gobj();
}

NothingAction::NothingAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

NothingAction::NothingAction(GtkNothingAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


NothingAction::NothingAction(NothingAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

NothingAction& NothingAction::operator=(NothingAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


NothingAction::~NothingAction() noexcept
{}


NothingAction::CppClassType NothingAction::nothingaction_class_; // initialize static member

GType NothingAction::get_type()
{
  return nothingaction_class_.init().get_type();
}


GType NothingAction::get_base_type()
{
  return gtk_nothing_action_get_type();
}

NothingAction::NothingAction()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutAction(Glib::ConstructParams(nothingaction_class_.init()))
{
  

}

Glib::RefPtr<NothingAction> NothingAction::get()
{

  auto retvalue = Glib::wrap(GTK_NOTHING_ACTION(gtk_nothing_action_get()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us
  return retvalue;
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::CallbackAction> wrap(GtkCallbackAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::CallbackAction>( dynamic_cast<Gtk::CallbackAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& CallbackAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &CallbackAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_callback_action_get_type();

  }

  return *this;
}


void CallbackAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* CallbackAction_Class::wrap_new(GObject* object)
{
  return new CallbackAction((GtkCallbackAction*)object);
}


/* The implementation: */

GtkCallbackAction* CallbackAction::gobj_copy()
{
  reference();
  return gobj();
}

CallbackAction::CallbackAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

CallbackAction::CallbackAction(GtkCallbackAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


CallbackAction::CallbackAction(CallbackAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

CallbackAction& CallbackAction::operator=(CallbackAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


CallbackAction::~CallbackAction() noexcept
{}


CallbackAction::CppClassType CallbackAction::callbackaction_class_; // initialize static member

GType CallbackAction::get_type()
{
  return callbackaction_class_.init().get_type();
}


GType CallbackAction::get_base_type()
{
  return gtk_callback_action_get_type();
}

Glib::RefPtr<CallbackAction> CallbackAction::create(const SlotShortcut& slot)
{
  return Glib::make_refptr_for_instance<CallbackAction>( new CallbackAction(slot) );
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::MnemonicAction> wrap(GtkMnemonicAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::MnemonicAction>( dynamic_cast<Gtk::MnemonicAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& MnemonicAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &MnemonicAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_mnemonic_action_get_type();

  }

  return *this;
}


void MnemonicAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* MnemonicAction_Class::wrap_new(GObject* object)
{
  return new MnemonicAction((GtkMnemonicAction*)object);
}


/* The implementation: */

GtkMnemonicAction* MnemonicAction::gobj_copy()
{
  reference();
  return gobj();
}

MnemonicAction::MnemonicAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

MnemonicAction::MnemonicAction(GtkMnemonicAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


MnemonicAction::MnemonicAction(MnemonicAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

MnemonicAction& MnemonicAction::operator=(MnemonicAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


MnemonicAction::~MnemonicAction() noexcept
{}


MnemonicAction::CppClassType MnemonicAction::mnemonicaction_class_; // initialize static member

GType MnemonicAction::get_type()
{
  return mnemonicaction_class_.init().get_type();
}


GType MnemonicAction::get_base_type()
{
  return gtk_mnemonic_action_get_type();
}

MnemonicAction::MnemonicAction()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutAction(Glib::ConstructParams(mnemonicaction_class_.init()))
{
  

}

Glib::RefPtr<MnemonicAction> MnemonicAction::get()
{

  auto retvalue = Glib::wrap(GTK_MNEMONIC_ACTION(gtk_mnemonic_action_get()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us
  return retvalue;
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::ActivateAction> wrap(GtkActivateAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::ActivateAction>( dynamic_cast<Gtk::ActivateAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& ActivateAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &ActivateAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_activate_action_get_type();

  }

  return *this;
}


void ActivateAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* ActivateAction_Class::wrap_new(GObject* object)
{
  return new ActivateAction((GtkActivateAction*)object);
}


/* The implementation: */

GtkActivateAction* ActivateAction::gobj_copy()
{
  reference();
  return gobj();
}

ActivateAction::ActivateAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

ActivateAction::ActivateAction(GtkActivateAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


ActivateAction::ActivateAction(ActivateAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

ActivateAction& ActivateAction::operator=(ActivateAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


ActivateAction::~ActivateAction() noexcept
{}


ActivateAction::CppClassType ActivateAction::activateaction_class_; // initialize static member

GType ActivateAction::get_type()
{
  return activateaction_class_.init().get_type();
}


GType ActivateAction::get_base_type()
{
  return gtk_activate_action_get_type();
}

ActivateAction::ActivateAction()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutAction(Glib::ConstructParams(activateaction_class_.init()))
{
  

}

Glib::RefPtr<ActivateAction> ActivateAction::get()
{

  auto retvalue = Glib::wrap(GTK_ACTIVATE_ACTION(gtk_activate_action_get()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us
  return retvalue;
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::SignalAction> wrap(GtkSignalAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::SignalAction>( dynamic_cast<Gtk::SignalAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& SignalAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &SignalAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_signal_action_get_type();

  }

  return *this;
}


void SignalAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* SignalAction_Class::wrap_new(GObject* object)
{
  return new SignalAction((GtkSignalAction*)object);
}


/* The implementation: */

GtkSignalAction* SignalAction::gobj_copy()
{
  reference();
  return gobj();
}

SignalAction::SignalAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

SignalAction::SignalAction(GtkSignalAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


SignalAction::SignalAction(SignalAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

SignalAction& SignalAction::operator=(SignalAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


SignalAction::~SignalAction() noexcept
{}


SignalAction::CppClassType SignalAction::signalaction_class_; // initialize static member

GType SignalAction::get_type()
{
  return signalaction_class_.init().get_type();
}


GType SignalAction::get_base_type()
{
  return gtk_signal_action_get_type();
}

SignalAction::SignalAction(const Glib::ustring& signal_name)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutAction(Glib::ConstructParams(signalaction_class_.init(), "signal_name", signal_name.c_str(), nullptr))
{
  

}

Glib::RefPtr<SignalAction> SignalAction::create(const Glib::ustring& signal_name)
{
  return Glib::make_refptr_for_instance<SignalAction>( new SignalAction(signal_name) );
}

Glib::ustring SignalAction::get_signal_name() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_signal_action_get_signal_name(const_cast<GtkSignalAction*>(gobj())));
}


Glib::PropertyProxy_ReadOnly< Glib::ustring > SignalAction::property_signal_name() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "signal-name");
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::NamedAction> wrap(GtkNamedAction* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::NamedAction>( dynamic_cast<Gtk::NamedAction*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& NamedAction_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &NamedAction_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_named_action_get_type();

  }

  return *this;
}


void NamedAction_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* NamedAction_Class::wrap_new(GObject* object)
{
  return new NamedAction((GtkNamedAction*)object);
}


/* The implementation: */

GtkNamedAction* NamedAction::gobj_copy()
{
  reference();
  return gobj();
}

NamedAction::NamedAction(const Glib::ConstructParams& construct_params)
:
  ShortcutAction(construct_params)
{

}

NamedAction::NamedAction(GtkNamedAction* castitem)
:
  ShortcutAction((GtkShortcutAction*)(castitem))
{}


NamedAction::NamedAction(NamedAction&& src) noexcept
: ShortcutAction(std::move(src))
{}

NamedAction& NamedAction::operator=(NamedAction&& src) noexcept
{
  ShortcutAction::operator=(std::move(src));
  return *this;
}


NamedAction::~NamedAction() noexcept
{}


NamedAction::CppClassType NamedAction::namedaction_class_; // initialize static member

GType NamedAction::get_type()
{
  return namedaction_class_.init().get_type();
}


GType NamedAction::get_base_type()
{
  return gtk_named_action_get_type();
}

NamedAction::NamedAction(const Glib::ustring& action_name)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutAction(Glib::ConstructParams(namedaction_class_.init(), "action_name", action_name.c_str(), nullptr))
{
  

}

Glib::RefPtr<NamedAction> NamedAction::create(const Glib::ustring& action_name)
{
  return Glib::make_refptr_for_instance<NamedAction>( new NamedAction(action_name) );
}

Glib::ustring NamedAction::get_action_name() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_named_action_get_action_name(const_cast<GtkNamedAction*>(gobj())));
}


Glib::PropertyProxy_ReadOnly< Glib::ustring > NamedAction::property_action_name() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "action-name");
}


} // namespace Gtk


