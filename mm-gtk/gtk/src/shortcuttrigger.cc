// Generated by gmmproc 2.74.0 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gtkmm/shortcuttrigger.h>
#include <gtkmm/private/shortcuttrigger_p.h>


/* Copyright (C) 2020 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#include <gtk/gtk.h>

namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Gtk::ShortcutTrigger> wrap(GtkShortcutTrigger* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::ShortcutTrigger>( dynamic_cast<Gtk::ShortcutTrigger*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& ShortcutTrigger_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &ShortcutTrigger_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_shortcut_trigger_get_type();

  }

  return *this;
}


void ShortcutTrigger_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* ShortcutTrigger_Class::wrap_new(GObject* object)
{
  return new ShortcutTrigger((GtkShortcutTrigger*)object);
}


/* The implementation: */

GtkShortcutTrigger* ShortcutTrigger::gobj_copy()
{
  reference();
  return gobj();
}

ShortcutTrigger::ShortcutTrigger(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

ShortcutTrigger::ShortcutTrigger(GtkShortcutTrigger* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


ShortcutTrigger::ShortcutTrigger(ShortcutTrigger&& src) noexcept
: Glib::Object(std::move(src))
{}

ShortcutTrigger& ShortcutTrigger::operator=(ShortcutTrigger&& src) noexcept
{
  Glib::Object::operator=(std::move(src));
  return *this;
}


ShortcutTrigger::~ShortcutTrigger() noexcept
{}


ShortcutTrigger::CppClassType ShortcutTrigger::shortcuttrigger_class_; // initialize static member

GType ShortcutTrigger::get_type()
{
  return shortcuttrigger_class_.init().get_type();
}


GType ShortcutTrigger::get_base_type()
{
  return gtk_shortcut_trigger_get_type();
}


ShortcutTrigger::ShortcutTrigger()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Glib::Object(Glib::ConstructParams(shortcuttrigger_class_.init()))
{
  

}

Glib::RefPtr<ShortcutTrigger> ShortcutTrigger::parse_string(const Glib::ustring& string)
{
  return Glib::wrap(gtk_shortcut_trigger_parse_string(string.c_str()));
}

Glib::ustring ShortcutTrigger::to_string() const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_shortcut_trigger_to_string(const_cast<GtkShortcutTrigger*>(gobj())));
}

Glib::ustring ShortcutTrigger::to_label(const Glib::RefPtr<const Gdk::Display>& display) const
{
  return Glib::convert_return_gchar_ptr_to_ustring(gtk_shortcut_trigger_to_label(const_cast<GtkShortcutTrigger*>(gobj()), const_cast<GdkDisplay*>(Glib::unwrap(display))));
}

bool ShortcutTrigger::equal(const Glib::RefPtr<const ShortcutTrigger>& trigger2) const
{
  return gtk_shortcut_trigger_equal(const_cast<GtkShortcutTrigger*>(gobj()), Glib::unwrap(trigger2));
}

int ShortcutTrigger::compare(const Glib::RefPtr<const ShortcutTrigger>& trigger2) const
{
  return gtk_shortcut_trigger_compare(const_cast<GtkShortcutTrigger*>(gobj()), Glib::unwrap(trigger2));
}

Gdk::KeyMatch ShortcutTrigger::trigger(const Glib::RefPtr<const Gdk::Event>& event, bool enable_mnemonics) const
{
  return static_cast<Gdk::KeyMatch>(gtk_shortcut_trigger_trigger(const_cast<GtkShortcutTrigger*>(gobj()), const_cast<GdkEvent*>(Glib::unwrap(event)), static_cast<int>(enable_mnemonics)));
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::NeverTrigger> wrap(GtkNeverTrigger* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::NeverTrigger>( dynamic_cast<Gtk::NeverTrigger*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& NeverTrigger_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &NeverTrigger_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_never_trigger_get_type();

  }

  return *this;
}


void NeverTrigger_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* NeverTrigger_Class::wrap_new(GObject* object)
{
  return new NeverTrigger((GtkNeverTrigger*)object);
}


/* The implementation: */

GtkNeverTrigger* NeverTrigger::gobj_copy()
{
  reference();
  return gobj();
}

NeverTrigger::NeverTrigger(const Glib::ConstructParams& construct_params)
:
  ShortcutTrigger(construct_params)
{

}

NeverTrigger::NeverTrigger(GtkNeverTrigger* castitem)
:
  ShortcutTrigger((GtkShortcutTrigger*)(castitem))
{}


NeverTrigger::NeverTrigger(NeverTrigger&& src) noexcept
: ShortcutTrigger(std::move(src))
{}

NeverTrigger& NeverTrigger::operator=(NeverTrigger&& src) noexcept
{
  ShortcutTrigger::operator=(std::move(src));
  return *this;
}


NeverTrigger::~NeverTrigger() noexcept
{}


NeverTrigger::CppClassType NeverTrigger::nevertrigger_class_; // initialize static member

GType NeverTrigger::get_type()
{
  return nevertrigger_class_.init().get_type();
}


GType NeverTrigger::get_base_type()
{
  return gtk_never_trigger_get_type();
}

NeverTrigger::NeverTrigger()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutTrigger(Glib::ConstructParams(nevertrigger_class_.init()))
{
  

}

Glib::RefPtr<NeverTrigger> NeverTrigger::get()
{

  auto retvalue = Glib::wrap(GTK_NEVER_TRIGGER(gtk_never_trigger_get()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us
  return retvalue;
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::KeyvalTrigger> wrap(GtkKeyvalTrigger* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::KeyvalTrigger>( dynamic_cast<Gtk::KeyvalTrigger*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& KeyvalTrigger_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &KeyvalTrigger_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_keyval_trigger_get_type();

  }

  return *this;
}


void KeyvalTrigger_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* KeyvalTrigger_Class::wrap_new(GObject* object)
{
  return new KeyvalTrigger((GtkKeyvalTrigger*)object);
}


/* The implementation: */

GtkKeyvalTrigger* KeyvalTrigger::gobj_copy()
{
  reference();
  return gobj();
}

KeyvalTrigger::KeyvalTrigger(const Glib::ConstructParams& construct_params)
:
  ShortcutTrigger(construct_params)
{

}

KeyvalTrigger::KeyvalTrigger(GtkKeyvalTrigger* castitem)
:
  ShortcutTrigger((GtkShortcutTrigger*)(castitem))
{}


KeyvalTrigger::KeyvalTrigger(KeyvalTrigger&& src) noexcept
: ShortcutTrigger(std::move(src))
{}

KeyvalTrigger& KeyvalTrigger::operator=(KeyvalTrigger&& src) noexcept
{
  ShortcutTrigger::operator=(std::move(src));
  return *this;
}


KeyvalTrigger::~KeyvalTrigger() noexcept
{}


KeyvalTrigger::CppClassType KeyvalTrigger::keyvaltrigger_class_; // initialize static member

GType KeyvalTrigger::get_type()
{
  return keyvaltrigger_class_.init().get_type();
}


GType KeyvalTrigger::get_base_type()
{
  return gtk_keyval_trigger_get_type();
}

KeyvalTrigger::KeyvalTrigger(guint keyval, Gdk::ModifierType modifiers)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutTrigger(Glib::ConstructParams(keyvaltrigger_class_.init(), "keyval", keyval, "modifiers", static_cast<GdkModifierType>(modifiers), nullptr))
{
  

}

Glib::RefPtr<KeyvalTrigger> KeyvalTrigger::create(guint keyval, Gdk::ModifierType modifiers)
{
  return Glib::make_refptr_for_instance<KeyvalTrigger>( new KeyvalTrigger(keyval, modifiers) );
}

guint KeyvalTrigger::get_keyval() const
{
  return gtk_keyval_trigger_get_keyval(const_cast<GtkKeyvalTrigger*>(gobj()));
}

Gdk::ModifierType KeyvalTrigger::get_modifiers() const
{
  return static_cast<Gdk::ModifierType>(gtk_keyval_trigger_get_modifiers(const_cast<GtkKeyvalTrigger*>(gobj())));
}


Glib::PropertyProxy_ReadOnly< guint > KeyvalTrigger::property_keyval() const
{
  return Glib::PropertyProxy_ReadOnly< guint >(this, "keyval");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Gdk::ModifierType>::value,
  "Type Gdk::ModifierType cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy_ReadOnly< Gdk::ModifierType > KeyvalTrigger::property_modifiers() const
{
  return Glib::PropertyProxy_ReadOnly< Gdk::ModifierType >(this, "modifiers");
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::MnemonicTrigger> wrap(GtkMnemonicTrigger* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::MnemonicTrigger>( dynamic_cast<Gtk::MnemonicTrigger*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& MnemonicTrigger_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &MnemonicTrigger_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_mnemonic_trigger_get_type();

  }

  return *this;
}


void MnemonicTrigger_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* MnemonicTrigger_Class::wrap_new(GObject* object)
{
  return new MnemonicTrigger((GtkMnemonicTrigger*)object);
}


/* The implementation: */

GtkMnemonicTrigger* MnemonicTrigger::gobj_copy()
{
  reference();
  return gobj();
}

MnemonicTrigger::MnemonicTrigger(const Glib::ConstructParams& construct_params)
:
  ShortcutTrigger(construct_params)
{

}

MnemonicTrigger::MnemonicTrigger(GtkMnemonicTrigger* castitem)
:
  ShortcutTrigger((GtkShortcutTrigger*)(castitem))
{}


MnemonicTrigger::MnemonicTrigger(MnemonicTrigger&& src) noexcept
: ShortcutTrigger(std::move(src))
{}

MnemonicTrigger& MnemonicTrigger::operator=(MnemonicTrigger&& src) noexcept
{
  ShortcutTrigger::operator=(std::move(src));
  return *this;
}


MnemonicTrigger::~MnemonicTrigger() noexcept
{}


MnemonicTrigger::CppClassType MnemonicTrigger::mnemonictrigger_class_; // initialize static member

GType MnemonicTrigger::get_type()
{
  return mnemonictrigger_class_.init().get_type();
}


GType MnemonicTrigger::get_base_type()
{
  return gtk_mnemonic_trigger_get_type();
}

MnemonicTrigger::MnemonicTrigger(guint keyval)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutTrigger(Glib::ConstructParams(mnemonictrigger_class_.init(), "keyval", keyval, nullptr))
{
  

}

Glib::RefPtr<MnemonicTrigger> MnemonicTrigger::create(guint keyval)
{
  return Glib::make_refptr_for_instance<MnemonicTrigger>( new MnemonicTrigger(keyval) );
}

guint MnemonicTrigger::get_keyval() const
{
  return gtk_mnemonic_trigger_get_keyval(const_cast<GtkMnemonicTrigger*>(gobj()));
}


Glib::PropertyProxy_ReadOnly< guint > MnemonicTrigger::property_keyval() const
{
  return Glib::PropertyProxy_ReadOnly< guint >(this, "keyval");
}


} // namespace Gtk


namespace Glib
{

Glib::RefPtr<Gtk::AlternativeTrigger> wrap(GtkAlternativeTrigger* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gtk::AlternativeTrigger>( dynamic_cast<Gtk::AlternativeTrigger*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& AlternativeTrigger_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &AlternativeTrigger_Class::class_init_function;

    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_alternative_trigger_get_type();

  }

  return *this;
}


void AlternativeTrigger_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* AlternativeTrigger_Class::wrap_new(GObject* object)
{
  return new AlternativeTrigger((GtkAlternativeTrigger*)object);
}


/* The implementation: */

GtkAlternativeTrigger* AlternativeTrigger::gobj_copy()
{
  reference();
  return gobj();
}

AlternativeTrigger::AlternativeTrigger(const Glib::ConstructParams& construct_params)
:
  ShortcutTrigger(construct_params)
{

}

AlternativeTrigger::AlternativeTrigger(GtkAlternativeTrigger* castitem)
:
  ShortcutTrigger((GtkShortcutTrigger*)(castitem))
{}


AlternativeTrigger::AlternativeTrigger(AlternativeTrigger&& src) noexcept
: ShortcutTrigger(std::move(src))
{}

AlternativeTrigger& AlternativeTrigger::operator=(AlternativeTrigger&& src) noexcept
{
  ShortcutTrigger::operator=(std::move(src));
  return *this;
}


AlternativeTrigger::~AlternativeTrigger() noexcept
{}


AlternativeTrigger::CppClassType AlternativeTrigger::alternativetrigger_class_; // initialize static member

GType AlternativeTrigger::get_type()
{
  return alternativetrigger_class_.init().get_type();
}


GType AlternativeTrigger::get_base_type()
{
  return gtk_alternative_trigger_get_type();
}

AlternativeTrigger::AlternativeTrigger(const Glib::RefPtr<const ShortcutTrigger>& first, const Glib::RefPtr<const ShortcutTrigger>& second)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  ShortcutTrigger(Glib::ConstructParams(alternativetrigger_class_.init(), "first", const_cast<GtkShortcutTrigger*>(Glib::unwrap(first)), "second", const_cast<GtkShortcutTrigger*>(Glib::unwrap(second)), nullptr))
{
  

}

Glib::RefPtr<AlternativeTrigger> AlternativeTrigger::create(const Glib::RefPtr<const ShortcutTrigger>& first, const Glib::RefPtr<const ShortcutTrigger>& second)
{
  return Glib::make_refptr_for_instance<AlternativeTrigger>( new AlternativeTrigger(first, second) );
}

Glib::RefPtr<const ShortcutTrigger> AlternativeTrigger::get_first() const
{
  auto retvalue = Glib::wrap(gtk_alternative_trigger_get_first(const_cast<GtkAlternativeTrigger*>(gobj())));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const ShortcutTrigger> AlternativeTrigger::get_second() const
{
  auto retvalue = Glib::wrap(gtk_alternative_trigger_get_second(const_cast<GtkAlternativeTrigger*>(gobj())));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}


static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Glib::RefPtr<const ShortcutTrigger>>::value,
  "Type Glib::RefPtr<const ShortcutTrigger> cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<const ShortcutTrigger> > AlternativeTrigger::property_first() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<const ShortcutTrigger> >(this, "first");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Glib::RefPtr<const ShortcutTrigger>>::value,
  "Type Glib::RefPtr<const ShortcutTrigger> cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<const ShortcutTrigger> > AlternativeTrigger::property_second() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<const ShortcutTrigger> >(this, "second");
}


} // namespace Gtk


