// Generated by gmmproc 2.74.0 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gtkmm/inscription.h>
#include <gtkmm/private/inscription_p.h>


/* Copyright 2022 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library. If not, see <http://www.gnu.org/licenses/>.
 */

#include <gtk/gtk.h>

using Overflow = Gtk::Inscription::Overflow;

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gtk::Inscription::Overflow>::value_type()
{
  return gtk_inscription_overflow_get_type();
}


namespace Glib
{

Gtk::Inscription* wrap(GtkInscription* object, bool take_copy)
{
  return dynamic_cast<Gtk::Inscription *> (Glib::wrap_auto ((GObject*)(object), take_copy));
}

} /* namespace Glib */

namespace Gtk
{


/* The *_Class implementation: */

const Glib::Class& Inscription_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Do not derive a GType, or use a derived class:
    gtype_ = gtk_inscription_get_type();

  }

  return *this;
}


Glib::ObjectBase* Inscription_Class::wrap_new(GObject* o)
{
  return manage(new Inscription((GtkInscription*)(o)));

}


/* The implementation: */

Inscription::Inscription(const Glib::ConstructParams& construct_params)
:
  Gtk::Widget(construct_params)
{
  }

Inscription::Inscription(GtkInscription* castitem)
:
  Gtk::Widget((GtkWidget*)(castitem))
{
  }


Inscription::Inscription(Inscription&& src) noexcept
: Gtk::Widget(std::move(src))
{}

Inscription& Inscription::operator=(Inscription&& src) noexcept
{
  Gtk::Widget::operator=(std::move(src));
  return *this;
}

Inscription::~Inscription() noexcept
{
  destroy_();
}

Inscription::CppClassType Inscription::inscription_class_; // initialize static member

GType Inscription::get_type()
{
  return inscription_class_.init().get_type();
}


GType Inscription::get_base_type()
{
  return gtk_inscription_get_type();
}


Inscription::Inscription()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::Widget(Glib::ConstructParams(inscription_class_.init()))
{
  

}

Inscription::Inscription(const Glib::ustring& text)
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gtk::Widget(Glib::ConstructParams(inscription_class_.init(), "text", text.c_str(), nullptr))
{
  

}

Glib::ustring Inscription::get_text() const
{
  return Glib::convert_const_gchar_ptr_to_ustring(gtk_inscription_get_text(const_cast<GtkInscription*>(gobj())));
}

void Inscription::set_text(const Glib::ustring& text)
{
  gtk_inscription_set_text(gobj(), text.empty() ? nullptr : text.c_str());
}

Pango::AttrList Inscription::get_attributes() const
{
  return Pango::AttrList((gtk_inscription_get_attributes(const_cast<GtkInscription*>(gobj()))));
}

void Inscription::set_attributes(Pango::AttrList& attrs)
{
  gtk_inscription_set_attributes(gobj(), (attrs).gobj());
}

void Inscription::set_markup(const Glib::ustring& markup)
{
  gtk_inscription_set_markup(gobj(), markup.empty() ? nullptr : markup.c_str());
}

Inscription::Overflow Inscription::get_text_overflow() const
{
  return static_cast<Inscription::Overflow>(gtk_inscription_get_text_overflow(const_cast<GtkInscription*>(gobj())));
}

void Inscription::set_text_overflow(Overflow overflow)
{
  gtk_inscription_set_text_overflow(gobj(), static_cast<GtkInscriptionOverflow>(overflow));
}

Pango::WrapMode Inscription::get_wrap_mode() const
{
  return static_cast<Pango::WrapMode>(gtk_inscription_get_wrap_mode(const_cast<GtkInscription*>(gobj())));
}

void Inscription::set_wrap_mode(Pango::WrapMode wrap_mode)
{
  gtk_inscription_set_wrap_mode(gobj(), static_cast<PangoWrapMode>(wrap_mode));
}

unsigned int Inscription::get_min_chars() const
{
  return gtk_inscription_get_min_chars(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_min_chars(unsigned int min_chars)
{
  gtk_inscription_set_min_chars(gobj(), min_chars);
}

unsigned int Inscription::get_nat_chars() const
{
  return gtk_inscription_get_nat_chars(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_nat_chars(unsigned int nat_chars)
{
  gtk_inscription_set_nat_chars(gobj(), nat_chars);
}

unsigned int Inscription::get_min_lines() const
{
  return gtk_inscription_get_min_lines(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_min_lines(unsigned int min_lines)
{
  gtk_inscription_set_min_lines(gobj(), min_lines);
}

unsigned int Inscription::get_nat_lines() const
{
  return gtk_inscription_get_nat_lines(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_nat_lines(unsigned int nat_lines)
{
  gtk_inscription_set_nat_lines(gobj(), nat_lines);
}

float Inscription::get_xalign() const
{
  return gtk_inscription_get_xalign(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_xalign(float xalign)
{
  gtk_inscription_set_xalign(gobj(), xalign);
}

float Inscription::get_yalign() const
{
  return gtk_inscription_get_yalign(const_cast<GtkInscription*>(gobj()));
}

void Inscription::set_yalign(float yalign)
{
  gtk_inscription_set_yalign(gobj(), yalign);
}


static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Pango::AttrList>::value,
  "Type Pango::AttrList cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy< Pango::AttrList > Inscription::property_attributes() 
{
  return Glib::PropertyProxy< Pango::AttrList >(this, "attributes");
}

Glib::PropertyProxy_ReadOnly< Pango::AttrList > Inscription::property_attributes() const
{
  return Glib::PropertyProxy_ReadOnly< Pango::AttrList >(this, "attributes");
}

Glib::PropertyProxy_WriteOnly< Glib::ustring > Inscription::property_markup() 
{
  return Glib::PropertyProxy_WriteOnly< Glib::ustring >(this, "markup");
}

Glib::PropertyProxy< unsigned int > Inscription::property_min_chars() 
{
  return Glib::PropertyProxy< unsigned int >(this, "min-chars");
}

Glib::PropertyProxy_ReadOnly< unsigned int > Inscription::property_min_chars() const
{
  return Glib::PropertyProxy_ReadOnly< unsigned int >(this, "min-chars");
}

Glib::PropertyProxy< unsigned int > Inscription::property_min_lines() 
{
  return Glib::PropertyProxy< unsigned int >(this, "min-lines");
}

Glib::PropertyProxy_ReadOnly< unsigned int > Inscription::property_min_lines() const
{
  return Glib::PropertyProxy_ReadOnly< unsigned int >(this, "min-lines");
}

Glib::PropertyProxy< unsigned int > Inscription::property_nat_chars() 
{
  return Glib::PropertyProxy< unsigned int >(this, "nat-chars");
}

Glib::PropertyProxy_ReadOnly< unsigned int > Inscription::property_nat_chars() const
{
  return Glib::PropertyProxy_ReadOnly< unsigned int >(this, "nat-chars");
}

Glib::PropertyProxy< unsigned int > Inscription::property_nat_lines() 
{
  return Glib::PropertyProxy< unsigned int >(this, "nat-lines");
}

Glib::PropertyProxy_ReadOnly< unsigned int > Inscription::property_nat_lines() const
{
  return Glib::PropertyProxy_ReadOnly< unsigned int >(this, "nat-lines");
}

Glib::PropertyProxy< Glib::ustring > Inscription::property_text() 
{
  return Glib::PropertyProxy< Glib::ustring >(this, "text");
}

Glib::PropertyProxy_ReadOnly< Glib::ustring > Inscription::property_text() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::ustring >(this, "text");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Inscription::Overflow>::value,
  "Type Inscription::Overflow cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy< Inscription::Overflow > Inscription::property_text_overflow() 
{
  return Glib::PropertyProxy< Inscription::Overflow >(this, "text-overflow");
}

Glib::PropertyProxy_ReadOnly< Inscription::Overflow > Inscription::property_text_overflow() const
{
  return Glib::PropertyProxy_ReadOnly< Inscription::Overflow >(this, "text-overflow");
}

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Pango::WrapMode>::value,
  "Type Pango::WrapMode cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy< Pango::WrapMode > Inscription::property_wrap_mode() 
{
  return Glib::PropertyProxy< Pango::WrapMode >(this, "wrap-mode");
}

Glib::PropertyProxy_ReadOnly< Pango::WrapMode > Inscription::property_wrap_mode() const
{
  return Glib::PropertyProxy_ReadOnly< Pango::WrapMode >(this, "wrap-mode");
}

Glib::PropertyProxy< float > Inscription::property_xalign() 
{
  return Glib::PropertyProxy< float >(this, "xalign");
}

Glib::PropertyProxy_ReadOnly< float > Inscription::property_xalign() const
{
  return Glib::PropertyProxy_ReadOnly< float >(this, "xalign");
}

Glib::PropertyProxy< float > Inscription::property_yalign() 
{
  return Glib::PropertyProxy< float >(this, "yalign");
}

Glib::PropertyProxy_ReadOnly< float > Inscription::property_yalign() const
{
  return Glib::PropertyProxy_ReadOnly< float >(this, "yalign");
}


} // namespace Gtk


