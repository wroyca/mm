// Generated by gmmproc 2.74.0 -- DO NOT MODIFY!


#include <glibmm.h>

#include <gdkmm/glcontext.h>
#include <gdkmm/private/glcontext_p.h>


/* Copyright (C) 2015 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <gdk/gdk.h>
#include <gdkmm/cairoutils.h>

namespace Gdk
{

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void GLContext::unset_use_es()
{
  gdk_gl_context_set_use_es(gobj(), -1);
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

} // namespace Gdk

namespace
{
} // anonymous namespace

// static
GType Glib::Value<Gdk::GLApi>::value_type()
{
  return gdk_gl_api_get_type();
}

#ifndef GDKMM_DISABLE_DEPRECATED
// static
GType Glib::Value<Gdk::GLAPI>::value_type()
{
  return gdk_gl_api_get_type();
}
#endif // GDKMM_DISABLE_DEPRECATED


Gdk::GLError::GLError(Gdk::GLError::Code error_code, const Glib::ustring& error_message)
:
  Glib::Error (GDK_GL_ERROR, error_code, error_message)
{}

Gdk::GLError::GLError(GError* gobject)
:
  Glib::Error (gobject)
{}

Gdk::GLError::Code Gdk::GLError::code() const
{
  return static_cast<Code>(Glib::Error::code());
}

void Gdk::GLError::throw_func(GError* gobject)
{
  throw Gdk::GLError(gobject);
}

// static
GType Glib::Value<Gdk::GLError::Code>::value_type()
{
  return gdk_gl_error_get_type();
}


namespace Glib
{

Glib::RefPtr<Gdk::GLContext> wrap(GdkGLContext* object, bool take_copy)
{
  return Glib::make_refptr_for_instance<Gdk::GLContext>( dynamic_cast<Gdk::GLContext*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Gdk
{


/* The *_Class implementation: */

const Glib::Class& GLContext_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &GLContext_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(gdk_gl_context_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void GLContext_Class::class_init_function(void* g_class, void* class_data)
{
  const auto klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);


}


Glib::ObjectBase* GLContext_Class::wrap_new(GObject* object)
{
  return new GLContext((GdkGLContext*)object);
}


/* The implementation: */

GdkGLContext* GLContext::gobj_copy()
{
  reference();
  return gobj();
}

GLContext::GLContext(const Glib::ConstructParams& construct_params)
:
  Gdk::DrawContext(construct_params)
{

}

GLContext::GLContext(GdkGLContext* castitem)
:
  Gdk::DrawContext((GdkDrawContext*)(castitem))
{}


GLContext::GLContext(GLContext&& src) noexcept
: Gdk::DrawContext(std::move(src))
{}

GLContext& GLContext::operator=(GLContext&& src) noexcept
{
  Gdk::DrawContext::operator=(std::move(src));
  return *this;
}


GLContext::~GLContext() noexcept
{}


GLContext::CppClassType GLContext::glcontext_class_; // initialize static member

GType GLContext::get_type()
{
  return glcontext_class_.init().get_type();
}


GType GLContext::get_base_type()
{
  return gdk_gl_context_get_type();
}


GLContext::GLContext()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(nullptr),
  Gdk::DrawContext(Glib::ConstructParams(glcontext_class_.init()))
{
  

}

Glib::RefPtr<Display> GLContext::get_display()
{
  auto retvalue = Glib::wrap(gdk_gl_context_get_display(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Display> GLContext::get_display() const
{
  return const_cast<GLContext*>(this)->get_display();
}

Glib::RefPtr<Surface> GLContext::get_surface()
{
  auto retvalue = Glib::wrap(gdk_gl_context_get_surface(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}

Glib::RefPtr<const Surface> GLContext::get_surface() const
{
  return const_cast<GLContext*>(this)->get_surface();
}

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
Glib::RefPtr<GLContext> GLContext::get_shared_context()
{
  auto retvalue = Glib::wrap(gdk_gl_context_get_shared_context(gobj()));
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us.
  return retvalue;
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
Glib::RefPtr<const GLContext> GLContext::get_shared_context() const
{
  return const_cast<GLContext*>(this)->get_shared_context();
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

void GLContext::get_version(int& major, int& minor) const
{
  gdk_gl_context_get_version(const_cast<GdkGLContext*>(gobj()), &(major), &(minor));
}

bool GLContext::is_legacy() const
{
  return gdk_gl_context_is_legacy(const_cast<GdkGLContext*>(gobj()));
}

bool GLContext::is_shared(const Glib::RefPtr<const GLContext>& other) const
{
  return gdk_gl_context_is_shared(const_cast<GdkGLContext*>(gobj()), const_cast<GdkGLContext*>(Glib::unwrap<Gdk::GLContext>(other)));
}

void GLContext::get_required_version(int& major, int& minor) const
{
  gdk_gl_context_get_required_version(const_cast<GdkGLContext*>(gobj()), &(major), &(minor));
}

void GLContext::set_required_version(int major, int minor)
{
  gdk_gl_context_set_required_version(gobj(), major, minor);
}

bool GLContext::get_debug_enabled() const
{
  return gdk_gl_context_get_debug_enabled(const_cast<GdkGLContext*>(gobj()));
}

void GLContext::set_debug_enabled(bool enabled)
{
  gdk_gl_context_set_debug_enabled(gobj(), static_cast<int>(enabled));
}

bool GLContext::get_forward_compatible() const
{
  return gdk_gl_context_get_forward_compatible(const_cast<GdkGLContext*>(gobj()));
}

void GLContext::set_forward_compatible(bool compatible)
{
  gdk_gl_context_set_forward_compatible(gobj(), static_cast<int>(compatible));
}

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void GLContext::set_allowed_apis(GLAPI apis)
{
  gdk_gl_context_set_allowed_apis(gobj(), static_cast<GdkGLAPI>(apis));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
GLAPI GLContext::get_allowed_apis() const
{
  return static_cast<GLAPI>(gdk_gl_context_get_allowed_apis(const_cast<GdkGLContext*>(gobj())));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
GLAPI GLContext::get_api() const
{
  return static_cast<GLAPI>(gdk_gl_context_get_api(const_cast<GdkGLContext*>(gobj())));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

void GLContext::set_allowed_apis(GLApi apis)
{
  gdk_gl_context_set_allowed_apis(gobj(), static_cast<GdkGLAPI>(apis));
}

GLApi GLContext::get_allowed_apis2() const
{
  return static_cast<GLApi>(gdk_gl_context_get_allowed_apis(const_cast<GdkGLContext*>(gobj())));
}

GLApi GLContext::get_api2() const
{
  return static_cast<GLApi>(gdk_gl_context_get_api(const_cast<GdkGLContext*>(gobj())));
}

#ifndef GDKMM_DISABLE_DEPRECATED
G_GNUC_BEGIN_IGNORE_DEPRECATIONS
void GLContext::set_use_es(bool use_es)
{
  gdk_gl_context_set_use_es(gobj(), static_cast<int>(use_es));
}
G_GNUC_END_IGNORE_DEPRECATIONS
#endif // GDKMM_DISABLE_DEPRECATED

bool GLContext::get_use_es() const
{
  return gdk_gl_context_get_use_es(const_cast<GdkGLContext*>(gobj()));
}

bool GLContext::realize()
{
  GError* gerror = nullptr;
  auto retvalue = gdk_gl_context_realize(gobj(), &(gerror));
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
  return retvalue;
}

void GLContext::make_current()
{
  gdk_gl_context_make_current(gobj());
}

Glib::RefPtr<GLContext> GLContext::get_current()
{

  auto retvalue = Glib::wrap(gdk_gl_context_get_current());
  if(retvalue)
    retvalue->reference(); //The function does not do a ref for us
  return retvalue;
}

void GLContext::clear_current()
{
  gdk_gl_context_clear_current();
}


#ifndef GDKMM_DISABLE_DEPRECATED

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<Glib::RefPtr<GLContext>>::value,
  "Type Glib::RefPtr<GLContext> cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy_ReadOnly< Glib::RefPtr<GLContext> > GLContext::property_shared_context() const
{
  return Glib::PropertyProxy_ReadOnly< Glib::RefPtr<GLContext> >(this, "shared-context");
}
#endif // GDKMM_DISABLE_DEPRECATED


#ifndef GDKMM_DISABLE_DEPRECATED

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<GLAPI>::value,
  "Type GLAPI cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy< GLAPI > GLContext::property_allowed_apis() 
{
  return Glib::PropertyProxy< GLAPI >(this, "allowed-apis");
}
#endif // GDKMM_DISABLE_DEPRECATED


#ifndef GDKMM_DISABLE_DEPRECATED

Glib::PropertyProxy_ReadOnly< GLAPI > GLContext::property_allowed_apis() const
{
  return Glib::PropertyProxy_ReadOnly< GLAPI >(this, "allowed-apis");
}
#endif // GDKMM_DISABLE_DEPRECATED


#ifndef GDKMM_DISABLE_DEPRECATED

static_assert(Glib::Traits::ValueCompatibleWithWrapProperty<GLAPI>::value,
  "Type GLAPI cannot be used in _WRAP_PROPERTY. "
  "There is no suitable template specialization of Glib::Value<>.");

Glib::PropertyProxy_ReadOnly< GLAPI > GLContext::property_api() const
{
  return Glib::PropertyProxy_ReadOnly< GLAPI >(this, "api");
}
#endif // GDKMM_DISABLE_DEPRECATED


} // namespace Gdk


